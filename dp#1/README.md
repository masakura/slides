# デザインパターン勉強会
## スライド


### デザインパターンとは?
多分、デザインパターンってほとんど知らない人もいると思われるので、簡単な解説くらいはする。

https://ja.wikipedia.org/wiki/%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3_%28%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%29

Wikipedia より、

> 書籍『オブジェクト指向における再利用のためのデザインパターン』において、GoF (Gang of Four; 四人組) と呼ばれる4人の共著者は、デザインパターンという用語を初めてソフトウェア開発に導入した。GoFは、エーリヒ・ガンマ、リチャード・ヘルム、ラルフ・ジョンソン、ジョン・ブリシディースの4人である。彼らは、その書籍の中で23種類のパターンを取り上げた。

> コンピュータのプログラミングで、素人と達人の間ではびっくりするほどの生産性の差があるが、その差はかなりの部分が経験の違いからきている。達人は、さまざまな難局を、何度も何度も耐え忍んで乗り切ってきている。そのような達人たちが同じ問題に取り組んだ場合、典型的にはみな同じパターンの解決策にたどり着くのだが、これがデザインパターンである (GoF)。

大事なことは、"オブジェクト指向における" "再利用のための" というところ。デザインパターンにはそれぞれメリットがあって、そのメリットを生かすためのパターンを再利用できるのがいいところ。


### とある開発会社の日常
今日は、みなさんに素晴らしい体験をしていただきます!

`ドキドキ、デスマ体験!` です。


#### 前提
とある開発会社はさまざまなツールを開発しています。今回出てくるツールはすべて特定のディレクトリ配下のファイル・ディレクトリの一覧をコンソールに出力する機能を持っています。分かりやすくするために、一覧をコンソールに出力する部分だけで本日はお話しします。


#### 序章
とある開発会社ではツール A をリリースしました。

ツール A のリリース後に、誰かがこのツールの汎用性のある部分を抽出して共通ライブラリ化して、他のツールでも流用すればよくね? とか言いました。

それにみんなが賛同しました。

誰にやらせようというお話になり...

そうだ、新人の BOCCO 君とかどうだろう? ということで、なんと BOCCO 君がこの重大な任務を任されることになりました。

BOCCO 君「えっ! そんな重大な任務自分には無理です!」
ツール A 担当者「便利そうな関数を抜き出すだけだから簡単だよ!」
BOCCO 君「(簡単なら...) がんばります!」

ということで、BOCCO 君はやる気になりました!

(この時点でドキドキしてきませんか? 嫌な予感しかない人手を挙げて!)


#### 共通ライブラリ化
BOCCO 君は、まずはツール A の関数のうち、他で使いまわせそうなものをリストアップし、それをツール A 担当者に見せました。それを元に、どの関数を抽出するかを決定し、抽出しました。

```javascript
/**
 * 指定されたパスのファイル・ディレクトリの一覧を再帰的に表示します。
 * @param nodePath {String} 探索する最初のファイルまたはディレクトリ。
 */
function displayRecursive(nodePath) {
  console.log(nodePath);

  // ディレクトリかファイルかを調べる
  var stat = fs.statSync(nodePath);

  if (stat.isDirectory()) {
    // ディレクトリの場合は配下のディレクトリ・ファイル一覧を取得して
    // 再帰呼び出しをして子を表示する
    var children = fs.readdirSync(nodePath);
    children.forEach(function (child) {
      displayRecursive(path.join(nodePath, child));
    });
  }
}

module.exports = {
  displayRecursive: displayRecursive
};
```

これに合わせて、ツール A も修正します。

```javascript
var common = require('./common.js');

common.displayRecursive(process.argv[2]);
```

まずは共通ライブラリ化は完了です。

ツール A 担当者「よくやったね! BOCCO 君!」
BOCCO 君「ありがとうございます!」


#### 新しいツール B の開発
新しくツール B の開発が始まった。

ツール B 担当者「BOCCO 君、言いにくいんだけど、行番号が必要なのよね」
BOCCO 君「分かりました!」

ここで注意しなければいけないのはこの共通ライブラリはツール A でも使われていること。なので、共通ライブラリで単純に行番号を表示すればいいというわけにはいかない。

```javascript
/**
 * 指定されたパスのファイル・ディレクトリの一覧を再帰的に表示します。
 * @param nodePath {String} 探索する最初のファイルまたはディレクトリ。
 * @param options {Object} オプション。
 */
function displayRecursive(nodePath, options) {
  var line = '';

  if (options && options.lineNumber) {
    // オプションに合わせて行番号を先頭に表示
    line += options.lineNumber + ': ';
    options.lineNumber++;
  }

  line += nodePath;

  console.log(line);

  // ディレクトリかファイルかを調べる
  var stat = fs.statSync(nodePath);

  if (stat.isDirectory()) {
    // ディレクトリの場合は配下のディレクトリ・ファイル一覧を取得して
    // 再帰呼び出しをして子を表示する
    var children = fs.readdirSync(nodePath);
    children.forEach(function (child) {
      displayRecursive(path.join(nodePath, child), options);
    });
  }
}

module.exports = {
  displayRecursive: displayRecursive
}
```

ツール B ではこうやって使います。

```javascript
var common = require('./common.js');

common.displayRecursive(process.argv[2], {lineNumber: 1});
```

ツール B 担当者「BOCCO 君のおかげで工期がかなり圧縮できたよ! ありがとう!」
BOCCO 君「ありがとうございます!」


#### 新しいツール C の開発
さらにツール C の開発も始まった。

ツール C 担当者「BOCCO 君、うちのツールだとファイルサイズも合わせて表示しないといけないのよね」
BOCCO 君「分かりました!」

BOCCO 君「できました!」
ツール C 担当者「あ、ごめん、ファイルサイズは先頭じゃなくて、ファイル名の後ろに出してね」
BOCCO 君「できました!」
ツール C 担当者「OK!」

....

ツール B 担当者「BOCCO 君!」
BOCCO 君「はい? なんでしょうか?」
ツール B 担当者「行番号がファイル名の後ろに出力されるようになったんだけど、何かした?」
BOCCO 君「あ!」
BOCCO 君「実はかくかくしかじか...」
ツール B 担当者「とにかく直して! お客さんかんかんだよ?」
BOCCO 君「分かりました...」

BOCCO 君「修正終わりました!」
ツール B 担当者「次、こういうことないよね?」
BOCCO 君「以後注意します」
ツール B 担当者「注意すれば問題ない?」
BOCCO 君「...」
ツール B 担当者「同じことをしないように対策を出してちょうだい」
BOCCO 君「分かりました...」

BOCCO 君「分かりましたとは言ったけど... 注意する以外なんもないよなあ...」

BOCCO 君「対策案作ってきました!」
ツール B 担当者「変更点を洗い出して事前に承認をもらうか。これなら再発防止になりそうだね。次からこれでよろしく!」
BOCCO 君「はい、分かりました!」

ツール A 担当者「ねぇ、BOCCO 君、共通ライブラリでバグ出したんだって?」
BOCCO 君「あ、はい...」
ツール A 担当者「うちには影響ないよね?」
BOCCO 君「多分...」
ツール A 担当者「多分は困るなあ...」
BOCCO 君「ツール B の担当者には変更の度に承認をもらうようにしましたが...」
ツール A 担当者「そうなの? それ、うちにも回してよ」
BOCCO 君「はい、分かりました!」

(もう、皆さん不安だらけではないでしょうか...)


#### しばらくして...
BOCCO 君にはいろんな要求が上がります。

ツール C 担当者「ファイルさ伊豆だけでなくてブロックサイズも欲しいんだけど!」
ツール D 担当者「行番号に 0 をつけて桁を揃えて!」
ツール E 担当者「パーミッションも出したい!」

その度に、BOCCO 君は各ツールの担当者に変更点を伝えて、バグがないことを認めてもらい、承認をもらい続けました。BOCCO 君はコード一行書き換えるのに大変時間がかかるようになり、責められるようになりました。(まあ、担当者がこれだけ多ければ、承認取ろうと思っても出張中で連絡つかないとか普通だよね...)


#### さらなる試練が...
BOCCO 君が疲弊しているところに更なる試練が...

ツール F 担当者「ファイルハッシュが一致するファイルだけを表示してよ!」
BOCCO 君「えっ! さすがにそれは...」
ツール F 担当者「できるよね?」
BOCCO 君「ちょっと...」
ツール F 担当者「できるよね? ね?」
BOCCO 君「分かりました...」

BOCCO 君は黙って会社を去りました...


#### 終わり
この後、この会社は右往左往するわけですが... もういいよね?


### 実はデザインパターンで解決できた
この問題はデザインパターンを導入していれば簡単に解決できたんです。

ここで問題です。どのパターンを使えばいいんでしょうか?

ツール B の行番号が欲しいという要望のときにこうやっちゃえばいいんです。

```javascript
/**
 * 指定されたパスのファイル・ディレクトリの一覧を再帰的に表示します。
 * @param nodePath {String} 探索する最初のファイルまたはディレクトリ。
 * @param optDisplay {Function} ファイル・ディレクトリを表示する関数。
 */
function displayRecursive(nodePath, optDisplay) {
  var display = optDisplay || function (line) {
    console.log(line);
  };
  display(nodePath);

  // ディレクトリかファイルかを調べる
  var stat = fs.statSync(nodePath);

  if (stat.isDirectory()) {
    // ディレクトリの場合は配下のディレクトリ・ファイル一覧を取得して
    // 再帰呼び出しをして子を表示する
    var children = fs.readdirSync(nodePath);
    children.forEach(function (child) {
      displayRecursive(path.join(nodePath, child), display);
    });
  }
}
```

このようにしておくと、どのように表示するのかを各ツールの担当者が好きにカスタマイズできるので、共通ライブラリを一切修正しなくてよく、つまり BOCCO 君は何もする必要がなかったわけです。

```javascript
/**
 * 行番号込みで表示する関数を生成するファクトリ
 */
function makeSimple () {
  var lineNumber = 1;
  return function (nodePath) {
    console.log(lineNumber + ': ' + nodePath);
  };
};

common.displayRecursive(makeSimple());
```

こんな感じです。

他のツールの要件も共通ライブラリを一切修正することなく対応することができます。

とある会社の例では、共通ライブラリにたった一行の変更をするだけでもかなりの時間を要することになったわけです。それで BOCCO 君は疲弊したわけですが、このようにしておけば BOCCO 君がやることなんてほとんどなかったわけです。


### デザインパターン適用前と適用後の違い
こういうお話をするのに欲でてくる言葉が`開放/閉鎖原則 (OCP open/closed principle)`です。

https://ja.wikipedia.org/wiki/%E9%96%8B%E6%94%BE/%E9%96%89%E9%8E%96%E5%8E%9F%E5%89%87

Wikipedia より

> 拡張に対して開いて (open) いなければならず、修正に対して閉じて (closed) いなければならない

デザインパターン適用前は、行番号を追加するという拡張に対して修正しなければいけませんでした。これは修正に対して閉じていませんでした。修正することでしか拡張をすることができませんでしたので、拡張に対して開いていませんでした。

それに対し、デザインパターン適用後は、行番号を追加するという拡張に対して修正する必要がありませんので、修正に対して閉じています。拡張は容易でしたので、拡張に対して開かれています。

ちょっとややこしいかもしれませんが、再利用したいモジュール (例えば共通ライブラリ) というものはこの開放/閉鎖原則が守られているかがとても重要です。共通ライブラリは BOCCO 君の例で挙げたとおり、修正が頻発するとトラブルが出ます。ですので、修正せずに (修正に対して閉じていて) 機能を拡張する (拡張に対して開かれている) 必要があるわけです。

ToDo 図解する。



## 話さなければいけないこと
### 使いどころ
デザインパターンで重要なのはデザインパターンをいつどのように適用するか? となる。不必要にデザインパターンを導入するとただ単に可読性が低下するだけになるので、そのメリットがいきるところに投入すること。

しかし、実際にはデザインパターンをどこに適用するかは大変なやましい。最初からそれが分かっているところは別だが、実は悩むくらいなら適用しない方がよい。拡張性が必要のないところに投入しても複雑さが増すばかりとなる。

大事なことは、デザインパターンが適用されていない状態を知ることで、かつ、その状態からのデザインパターンの適用した状態への移行パスを持つことである。(リファクタリングとか単体テストが役に立つ)

このようにすることで、デザインパターンの乱用を抑え、必要なところに必要な時にデザインパターンを導入することができる。

大切なのでもう一度。デザインパターンを適用するか悩む所には適用しないこと。その代わり、仕様変更やバグ修正で適用すべきだと思ったら、即座にテストコードでガードしてリファクタリングして、デザインパターンを適用すること。


## ネタ候補
* デザインパターンとは?
* デザインパターン FAQ